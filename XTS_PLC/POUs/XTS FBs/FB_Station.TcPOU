<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Station" Id="{044dcdb0-796d-4bda-a3b7-df20cd71aff3}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Station IMPLEMENTS I_StationInteraction
VAR_INPUT
	ax						: REFERENCE TO ARRAY [1..Tc3_XTS_Utility.TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu] OF FB_Mover;	//Movers
	stCfg 					: REFERENCE TO stStationCfg;
	udiNumMovers			: UDINT;		//Number of Movers into the system
	lrPartLength			: LREAL;
	bInvertPolarity			: BOOL;
	INextStation			: I_StationInteraction;
END_VAR
VAR_OUTPUT
	udiNumMoversIn			: UDINT;		//Number of Movers into station
	udiErrorID				: UDINT;
END_VAR
VAR
	fbMoversFIFO			: FB_MoversFIFO;	
	bWaitingMovers			: BOOL;
	udiSequenceState		: UDINT;
	sMoversWaiting			: STRING;
	sMoversIn				: STRING;
	lrActualWaitingTime		: LREAL;
	lrActualProcessTime		: LREAL;
END_VAR
VAR CONSTANT
	START_POSITION_ON_PART_STATION 	: DWORD := 16#03080272;
	END_POSITION_ON_PART_STATION 	: DWORD := 16#03080273;
	STOP_POSITIONS_STATION 			: DWORD := 16#0308028D;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbMoversFIFO(ax := ax);	
]]></ST>
    </Implementation>
    <Folder Name="Configuration" Id="{98b41278-908c-4e1f-bc95-32a5c98977fe}" />
    <Method Name="AddMover" Id="{311f5327-14aa-4b71-8341-6aaa6922ac74}">
      <Declaration><![CDATA[METHOD AddMover : BOOL
VAR_INPUT
	udiMoverID : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMoversFIFO.m_Add(udiMoverID);
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Cfg" Id="{df3bafe3-40fc-455e-ba96-f73e28e62b7b}">
      <Declaration><![CDATA[PROPERTY Cfg : reference to stStationCfg]]></Declaration>
      <Get Name="Get" Id="{c33c444b-7999-4930-ac48-bea88e0e077f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Cfg REF= stCfg;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Sequence1" Id="{094ad280-bbb4-43e1-823e-5d126e94065e}">
      <Declaration><![CDATA[METHOD Sequence1 : BOOL
VAR_INPUT
	bExecute : BOOL;
END_VAR
VAR_OUTPUT
	bBusy	: BOOL;
	bError	: BOOL;
	bErrorID: BOOL;
END_VAR
VAR_INST
	iState 	: INT;
	m_bBusy	: BOOL;
	i		: UDINT;
	fbTON	: TON;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bExecute = FALSE THEN iState := 0; END_IF
CASE iState OF
	0 :
		IF bExecute THEN
			fbTON(IN := FALSE);
			iState := iState + 10;
		END_IF

	10 : //Check for movers between previous station position and start position
		 fbTON(IN := TRUE, PT := LREAL_TO_TIME(stCfg.lrProcessingTime*1000.0));
		IF fbTON.Q THEN
			iState := iState + 10;
		END_IF
		
	20 : //Done
		Sequence1 := TRUE;
		IF bExecute = FALSE THEN
			iState := 0;
		END_IF
	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Sequence2" Id="{8bfcf8e7-89a8-4fff-8c75-8ea0c8fb227f}">
      <Declaration><![CDATA[METHOD Sequence2 : BOOL
VAR_INPUT
	bEnable 		: BOOL;
	bAbort			: BOOL;
END_VAR
VAR_OUTPUT
	m_udiErrorID	: UDINT;
END_VAR
VAR_INST
	udiState  		: UDINT;
	stCurrentCfg	: stStationCfg;
	fbTON			: ARRAY [1..5] OF TON;
	i				: UDINT;
	bAllDOne		: BOOL;
	m_bBusy			: BOOL;
	aMoversIN		: ARRAY [1..3] OF UDINT;
	ErrorID			: UDINT;
	tmInitProcessTime 	: TIME;
	tmInitWaitTime		: TIME;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* 
	0. External Method to Add Movers into station
	1. Check if there is some mover in FIFO
	2. Send Mover to Stop Position
	3. Check Movers all StandStill and Reset Mover Commands
	4. Processing
	5. Send Movers to next FIFO Station
*)
IF bAbort AND udiState <> 100 THEN udiState := 100; END_IF

CASE udiState OF
	0 : //Wait for enable command
		IF bEnable THEN 
			udiNumMoversIn := 0;
			udiState := udiState + 10; 
		END_IF 
		
	10 : //Clear commands
		fbMoversFIFO.m_Clear();
		FOR i:=1 TO udiNumMovers DO
			//
			ax[i].clearCmd();
		END_FOR
		FOR i:= 1 TO 3 DO
			fbTon[i](IN := FALSE);
		END_FOR
		udiState := 19;
		
	19 : //Update configuration parameters
		stCurrentCfg 						:= stCfg;
		fbMoversFIFO.lrFirstStopPosition 	:= stCurrentCfg.lrStartPosition + stCurrentCfg.lrStopPosition[1];
		fbMoversFIFO.lrPartLength 			:= lrPartLength;
		tmInitWaitTime := TIME();
		udiState := udiState + 1;
		
	20 : //Check for new movers into FIFO
		m_bBusy 		:= TRUE;
		bWaitingMovers 	:= TRUE;
		IF fbMoversFIFO.nMovers > 0 AND udiNumMoversIn < stCurrentCfg.uiNumStopPositions THEN
			udiNumMoversIn 				:= udiNumMoversIn + 1;
			IF fbMoversFIFO.m_Extract(m_udiMoverID => aMoversIN[udiNumMoversIn]) THEN
				ax[aMoversIN[udiNumMoversIn]].clearCmd();
				bWaitingMovers := FALSE;
				udiState := udiState + 1;
			END_IF
		END_IF
		IF bEnable = FALSE THEN
			udiState := 100;
		END_IF
		
	21 : //Send Mover to Stop Position
		bAllDone := TRUE;
		FOR i:=1 TO udiNumMoversIn DO
			bAllDone := bAllDone AND ax[aMoversIN[i]].moveca_bytime(TRUE, stCurrentCfg.lrStartPosition + stCurrentCfg.lrStopPosition[stCurrentCfg.uiNumStopPositions - i + 1], stCfg.lrTravelTime, ErrorID => ErrorID);
		END_FOR
		//If Station full process
		IF udiNumMoversIn = stCurrentCfg.uiNumStopPositions THEN
			IF bAllDone THEN 
				lrActualWaitingTime := (TIME_TO_LREAL(TIME() - tmInitWaitTime)-10.0)/1000.0;
				udiState := 30; 
			END_IF
		ELSE
			udiState := udiState - 1;
		END_IF
		IF ErrorID <> 0 THEN
			udiState := 999;
		END_IF
		
	30 : //Check if all movers are standstill and reset commands
		bAllDone := TRUE;
		FOR i:= 1 TO udiNumMoversIn DO	
			bAllDone := bAllDone AND ax[aMoversIN[i]].standstill();
			ax[aMoversIN[i]].clearCmd();
		END_FOR
		IF bAllDone THEN
			tmInitProcessTime := TIME();
			udiState := udiState + 10;
		END_IF
		
	40 : //Processing
		bAllDone := TRUE;
		FOR i:= 1 TO stCurrentCfg.uiNumStopPositions DO
			fbTon[i](IN := TRUE, PT := LREAL_TO_TIME(stCfg.lrProcessingTime*1000));
			bAllDone := bAllDone AND fbTON[i].Q;
		END_FOR
		IF (bAllDone AND stCfg.bEnableManualAck = FALSE) OR (stCfg.bEnableManualAck = TRUE AND stCfg.bManualAck) THEN
			FOR i:= 1 TO stCurrentCfg.uiNumStopPositions DO
				ax[aMoversIN[i]].clearCmd();
				fbTon[i](IN := FALSE);
			END_FOR
			lrActualProcessTime := (TIME_TO_LREAL(TIME() - tmInitProcessTime)-10.0)/1000.0;
			udiState := udiState + 10;
		END_IF
		
	50 : //Send out movers
		FOR i:= 1 TO udiNumMoversIn DO
		 	INextStation.AddMover(aMoversIN[i]);
			ax[aMoversIN[i]].moveca_bytime(TRUE, lrPosition := INextStation.Cfg.lrStartPosition, INextStation.Cfg.lrTravelTime, ErrorID => ErrorID);
		END_FOR
		udiNumMoversIn	:= 0;
		udiState 		:= 19;
		IF ErrorID <> 0 THEN
			udiState := 999;
		END_IF
		
	100 : //Abort
		m_bBusy := FALSE;
		bWaitingMovers := FALSE;
		IF bEnable = FALSE THEN
			ErrorID := 0;
			fbMoversFIFO.m_Clear();
			udiState := 0;
		END_IF
		
	999 : //Error
		m_bBusy := FALSE;
		bWaitingMovers := FALSE;
		IF bEnable = FALSE THEN
			fbMoversFIFO.m_Clear();
			ErrorID := 0;
			udiState := 0;
		END_IF
		
END_CASE
Sequence2 			:= m_bBusy;
udiSequenceState 	:= udiState;
udiErrorID			:= ErrorID;
m_udiErrorID		:= udiErrorID;

sMoversWaiting := '';
FOR i:= 1 TO fbMoversFIFO.nMovers DO
	sMoversWaiting := CONCAT(sMoversWaiting, UDINT_TO_STRING(fbMoversFIFO.aMoversFIFO[i]));
	IF i < fbMoversFIFO.nMovers THEN sMoversWaiting := CONCAT(sMoversWaiting, ', '); END_IF
END_FOR
sMoversIn := '';
FOR i:= 1 TO udiNumMoversIn DO
	sMoversIn := CONCAT(sMoversIn, UDINT_TO_STRING(aMoversIN[i]));
	IF i < udiNumMoversIn THEN sMoversIn := concat(sMoversIn, ', '); END_IF
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetStationInfo" Id="{864b431a-7d13-4073-a027-d3c853e0124b}" FolderPath="Configuration\">
      <Declaration><![CDATA[METHOD SetStationInfo : BOOL
VAR_INPUT
	bExecute		: BOOL;
	OTCID			: DWORD;
	bDisable		: BOOL;
END_VAR
VAR_INST
	iState 	 		: INT;
	fbADSWrite 		: adswrite;
	lrStartPos		: LREAL;
	lrEndPos		: LREAL;
	aStopPos		: ARRAY [1..3] OF LREAL;
	lrTmp			: LREAL;
	aTmp			: ARRAY [1..3] OF LREAL;
	lrDistance		: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE iState OF
	0 : 
		IF bExecute THEN
			fbADSWrite(WRITE:= FALSE);
			fbMoversFIFO(ax := ax);	
			iState 	:= iState + 1;
		END_IF
	
	1 : //Write Init position
		lrStartPos 	:= SEL(bInvertPolarity, stCfg.lrStartPosition, lrPartLength - stCfg.lrEndPosition);
		lrEndPos 	:= SEL(bInvertPolarity, stCfg.lrEndPosition, lrPartLength - stCfg.lrStartPosition);
		IF bDisable THEN
			lrStartPos := lrEndPos := 0;
		END_IF
		fbADSWrite(
			NETID:= , 
			PORT:= 350, 
			IDXGRP:= OTCID, 
			IDXOFFS:= START_POSITION_ON_PART_STATION, 
			LEN:= SIZEOF(lrStartPos), 
			SRCADDR:= ADR(lrStartPos), 
			WRITE:= TRUE, 
			TMOUT:= , 
			BUSY=> , 
			ERR=> , 
			ERRID=> );
	
		IF fbADSWrite.BUSY = FALSE AND fbADSWrite.ERR = FALSE THEN
			fbADSWrite(WRITE := FALSE);
			iState := iState + 1;
		END_IF	
			
	2 : //Write End Position
		fbADSWrite(
			NETID:= , 
			PORT:= 350, 
			IDXGRP:= OTCID, 
			IDXOFFS:= END_POSITION_ON_PART_STATION, 
			LEN:= SIZEOF(lrEndPos), 
			SRCADDR:= ADR(lrEndPos), 
			WRITE:= TRUE, 
			TMOUT:= , 
			BUSY=> , 
			ERR=> , 
			ERRID=> );
	
		IF fbADSWrite.BUSY = FALSE AND fbADSWrite.ERR = FALSE THEN
			fbADSWrite(WRITE := FALSE);
			iState := iState + 1;
		END_IF
		
	3 : //Write Stop Positions
		aStopPos[1] := SEL(bInvertPolarity, stCfg.lrStopPosition[1], (stCfg.lrEndPosition - stCfg.lrStartPosition) - stCfg.lrStopPosition[1]); 
		aStopPos[2] := SEL(bInvertPolarity, stCfg.lrStopPosition[2], (stCfg.lrEndPosition - stCfg.lrStartPosition) - stCfg.lrStopPosition[2]); 
		aStopPos[3] := SEL(bInvertPolarity, stCfg.lrStopPosition[3], (stCfg.lrEndPosition - stCfg.lrStartPosition) - stCfg.lrStopPosition[3]); 
		IF stCfg.uiNumStopPositions = 1 AND NOT bDisable THEN
			aTmp[1] := aStopPos[1];
			aTmp[2] := aStopPos[1];
			aTmp[3] := aStopPos[1];
		ELSIF stCfg.uiNumStopPositions = 2 AND NOT bDisable THEN
			aTmp[1] := SEL(bInvertPolarity, aStopPos[1], aStopPos[2]);
			aTmp[2] := SEL(bInvertPolarity, aStopPos[2], aStopPos[1]);
			aTmp[3] := SEL(bInvertPolarity, aStopPos[2], aStopPos[1]);
		ELSIF stCfg.uiNumStopPositions = 3 AND NOT bDisable THEN
			aTmp[1] := SEL(bInvertPolarity, aStopPos[1], aStopPos[3]);
			aTmp[2] := SEL(bInvertPolarity, aStopPos[2], aStopPos[2]);
			aTmp[3] := SEL(bInvertPolarity, aStopPos[3], aStopPos[1]);
		ELSE
			aTmp[1]	:= 0.0;
			aTmp[2] := 0.0;
			aTmp[3] := 0.0;
		END_IF
		fbADSWrite(
			NETID:= , 
			PORT:= 350, 
			IDXGRP:= OTCID, 
			IDXOFFS:= STOP_POSITIONS_STATION, 
			LEN:= SIZEOF(aTmp), 
			SRCADDR:= ADR(aTmp), 
			WRITE:= TRUE, 
			TMOUT:= , 
			BUSY=> , 
			ERR=> , 
			ERRID=> );
	
		IF fbADSWrite.BUSY = FALSE AND fbADSWrite.ERR = FALSE THEN
			fbADSWrite(WRITE := FALSE);
			iState := iState + 1;
		END_IF
		
	4 : //Job Done
		SetStationInfo := TRUE;
		IF bExecute = FALSE THEN
			iState := 0;
		END_IF
	
END_CASE

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>